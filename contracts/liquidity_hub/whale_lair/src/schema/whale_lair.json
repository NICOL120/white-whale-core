{
  "contract_name": "whale_lair",
  "contract_version": "0.1.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "growth_rate",
      "staking_denom",
      "unstaking_period"
    ],
    "properties": {
      "growth_rate": {
        "description": "Weight grow rate",
        "type": "integer",
        "format": "uint8",
        "minimum": 0.0
      },
      "staking_denom": {
        "description": "Denom of the asset to be staked",
        "type": "string"
      },
      "unstaking_period": {
        "description": "Unstaking period in number of blocks",
        "type": "integer",
        "format": "uint64",
        "minimum": 0.0
      }
    },
    "additionalProperties": false
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "description": "Stakes the specified amount of tokens.",
        "type": "object",
        "required": [
          "stake"
        ],
        "properties": {
          "stake": {
            "type": "object",
            "required": [
              "amount"
            ],
            "properties": {
              "amount": {
                "$ref": "#/definitions/Uint128"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Unstakes the specified amount of tokens.",
        "type": "object",
        "required": [
          "unstake"
        ],
        "properties": {
          "unstake": {
            "type": "object",
            "required": [
              "amount"
            ],
            "properties": {
              "amount": {
                "$ref": "#/definitions/Uint128"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Sends claimable unstaked tokens to the user.",
        "type": "object",
        "required": [
          "claim"
        ],
        "properties": {
          "claim": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Updates the [Config] of the contract.",
        "type": "object",
        "required": [
          "update_config"
        ],
        "properties": {
          "update_config": {
            "type": "object",
            "properties": {
              "growth_rate": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint8",
                "minimum": 0.0
              },
              "owner": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "unstaking_period": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "description": "Returns the [Config] of te contract.",
        "type": "object",
        "required": [
          "config"
        ],
        "properties": {
          "config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the amount of tokens that have been staked by the specified address.",
        "type": "object",
        "required": [
          "staked"
        ],
        "properties": {
          "staked": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the amount of tokens that are been unstaked by the specified address. Allows pagination with start_after and limit.",
        "type": "object",
        "required": [
          "unstaking"
        ],
        "properties": {
          "unstaking": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              },
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint8",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the amount of unstaking tokens of the specified address that can be claimed, i.e. that have passed the unstaking period.",
        "type": "object",
        "required": [
          "claimable"
        ],
        "properties": {
          "claimable": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the weight of the address.",
        "type": "object",
        "required": [
          "weight"
        ],
        "properties": {
          "weight": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ]
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "claimable": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ClaimableResponse",
      "description": "Response for the Claimable query",
      "type": "object",
      "required": [
        "claimable_amount"
      ],
      "properties": {
        "claimable_amount": {
          "$ref": "#/definitions/Uint128"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Config",
      "type": "object",
      "required": [
        "growth_rate",
        "owner",
        "staking_denom",
        "unstaking_period"
      ],
      "properties": {
        "growth_rate": {
          "description": "A scalar that controls the effect of time on the weight of a stake. If the growth rate is set to zero, time will have no impact on the weight. If the growth rate is set to one, the stake's weight will increase by one for each block.",
          "type": "integer",
          "format": "uint8",
          "minimum": 0.0
        },
        "owner": {
          "description": "Owner of the contract.",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "staking_denom": {
          "description": "Denom of the asset to be staked. Can't only be set at instantiation.",
          "type": "string"
        },
        "unstaking_period": {
          "description": "Unstaking period in seconds",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        }
      }
    },
    "staked": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "StakedResponse",
      "description": "Response for the Staked query",
      "type": "object",
      "required": [
        "staked"
      ],
      "properties": {
        "staked": {
          "$ref": "#/definitions/Uint128"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "unstaking": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "UnstakingResponse",
      "description": "Response for the Unstaking query",
      "type": "object",
      "required": [
        "total_amount",
        "unstaking_requests"
      ],
      "properties": {
        "total_amount": {
          "$ref": "#/definitions/Uint128"
        },
        "unstaking_requests": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Stake"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Stake": {
          "type": "object",
          "required": [
            "amount",
            "block_height",
            "weight"
          ],
          "properties": {
            "amount": {
              "description": "The amount of staked tokens.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "block_height": {
              "description": "The block height at which the stake was done.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "weight": {
              "description": "The weight of the stake at the given block height.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "weight": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "StakingWeightResponse",
      "description": "Response for the Weight query.",
      "type": "object",
      "required": [
        "address",
        "global_weight",
        "share",
        "weight"
      ],
      "properties": {
        "address": {
          "type": "string"
        },
        "global_weight": {
          "$ref": "#/definitions/Uint128"
        },
        "share": {
          "$ref": "#/definitions/Uint128"
        },
        "weight": {
          "$ref": "#/definitions/Uint128"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    }
  }
}
